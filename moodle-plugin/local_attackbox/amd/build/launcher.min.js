define(["jquery", "core/str"], function ($, Str) {
"use strict";
const PROGRESS_THRESHOLDS = [5, 10, 18, 25, 33, 42, 50, 62, 70, 85, 94, 100];
const STRING_KEYS = [
{ key: "button:launch", component: "local_attackbox" },
{ key: "button:active", component: "local_attackbox" },
{ key: "button:terminate", component: "local_attackbox" },
{ key: "button:tooltip", component: "local_attackbox" },
{ key: "button:tooltip_active", component: "local_attackbox" },
{ key: "button:usage_dashboard", component: "local_attackbox" },
{ key: "timer:time_remaining", component: "local_attackbox" },
{ key: "overlay:title", component: "local_attackbox" },
{ key: "overlay:subtitle", component: "local_attackbox" },
{ key: "overlay:cancel", component: "local_attackbox" },
{ key: "error:title", component: "local_attackbox" },
{ key: "error:retry", component: "local_attackbox" },
{ key: "error:close", component: "local_attackbox" },
{ key: "success:title", component: "local_attackbox" },
{ key: "success:message", component: "local_attackbox" },
{ key: "success:open", component: "local_attackbox" },
{ key: "terminate:confirm", component: "local_attackbox" },
{ key: "terminate:success", component: "local_attackbox" },
{ key: "terminate:error", component: "local_attackbox" },
{ key: "idle:warning_title", component: "local_attackbox" },
{ key: "idle:warning_message", component: "local_attackbox" },
{ key: "idle:critical_message", component: "local_attackbox" },
{ key: "idle:keep_active", component: "local_attackbox" },
{ key: "idle:focus_mode", component: "local_attackbox" },
{ key: "progress:5", component: "local_attackbox" },
{ key: "progress:10", component: "local_attackbox" },
{ key: "progress:18", component: "local_attackbox" },
{ key: "progress:25", component: "local_attackbox" },
{ key: "progress:33", component: "local_attackbox" },
{ key: "progress:42", component: "local_attackbox" },
{ key: "progress:50", component: "local_attackbox" },
{ key: "progress:62", component: "local_attackbox" },
{ key: "progress:70", component: "local_attackbox" },
{ key: "progress:85", component: "local_attackbox" },
{ key: "progress:94", component: "local_attackbox" },
{ key: "progress:100", component: "local_attackbox" },
];
const HEARTBEAT_INTERVAL = 30000; 
const IDLE_CHECK_INTERVAL = 10000; 
class AttackBoxLauncher {
constructor(config, strings) {
this.config = config;
this.strings = strings;
this.sessionId = null;
this.pollTimer = null;
this.isLaunching = false;
this.hasActiveSession = false;
this.activeSessionUrl = null;
this.lastQuotaWarning = null; 
this.currentUsageData = null; 
this.sessionExpiresAt = null; 
this.timerInterval = null; 
this.eduInterval = null; 
this.currentEduIndex = 0; 
this.currentAttackIndex = 0; 
this.heartbeatInterval = null; 
this.idleCheckInterval = null; 
this.lastUserActivity = Date.now(); 
this.isTabVisible = !document.hidden; 
this.focusMode = false; 
this.idleWarningShown = false; 
this.idleThresholds = null; 
this.eduContent = [
"The average cost of a data breach in 2024 is $4.45 million. Proper security testing can prevent most breaches.",
"90% of cyberattacks start with a phishing email. Always verify sender addresses and suspicious links.",
"SQL Injection is still the #1 web application vulnerability. Always use parameterized queries.",
"Cross-Site Scripting (XSS) affects 75% of web applications. Sanitize all user input!",
"Weak passwords are responsible for 81% of data breaches. Use strong, unique passwords for every account.",
"Regular security updates close 95% of known vulnerabilities. Keep your systems patched!",
"Two-Factor Authentication (2FA) blocks 99.9% of automated attacks. Enable it everywhere possible.",
"The average time to detect a breach is 207 days. Continuous monitoring is essential.",
"Over 30,000 websites are hacked daily. Regular security audits are your best defense.",
"Port scanning is the first step in 80% of attacks. Understanding reconnaissance helps you defend better.",
"Nmap (Network Mapper) is used to discover hosts and services on a network. It's essential for penetration testing.",
"Metasploit Framework contains over 2,000 exploits. Ethical hackers use it to test system security.",
"Burp Suite intercepts HTTP traffic to find web application vulnerabilities before attackers do.",
"The OWASP Top 10 lists the most critical web application security risks. Learn them to secure your apps.",
"DNS tunneling can exfiltrate data slowly. Monitor unusual DNS query patterns in your network.",
"Privilege escalation is how attackers gain admin access. Always follow the principle of least privilege.",
];
this.attackTypes = [
{ name: "SQL Injection", icon: "&#128137;", color: "#ff5722" },
{ name: "XSS Attack", icon: "&#9889;", color: "#ff9800" },
{ name: "Phishing", icon: "&#127907;", color: "#f44336" },
{ name: "Port Scan", icon: "&#128269;", color: "#00bcd4" },
{ name: "Brute Force", icon: "&#128296;", color: "#9c27b0" },
{ name: "Man-in-Middle", icon: "&#128065;", color: "#673ab7" },
{ name: "DoS Attack", icon: "&#128165;", color: "#e91e63" },
{ name: "Buffer Overflow", icon: "&#128230;", color: "#ff5722" },
];
this.init();
}
init() {
this.createButton();
this.createOverlay();
this.createNotificationBanner();
this.createIdleWarningModal();
this.createUsageDashboardLink();
this.bindEvents();
this.bindIdleDetectionEvents();
this.updateUsageDisplay();
setTimeout(() => {
this.checkExistingSession().catch((err) => {
console.log("Could not check for existing session:", err);
});
}, 100);
setInterval(() => this.updateUsageDisplay(), 30000);
}
createIdleWarningModal() {
const html = `
<div id="attackbox-idle-warning" class="attackbox-idle-warning" style="display: none;">
<div class="attackbox-idle-warning-content">
<div class="attackbox-idle-warning-header">
<div class="attackbox-idle-warning-icon">
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="12" cy="12" r="10"/>
<line x1="12" y1="8" x2="12" y2="12"/>
<line x1="12" y1="16" x2="12.01" y2="16"/>
</svg>
</div>
<div class="attackbox-idle-warning-info">
<h4 class="attackbox-idle-warning-title">${
this.strings.idleWarningTitle || "Session Idle"
}</h4>
<p id="attackbox-idle-warning-message" class="attackbox-idle-warning-message">
${
this.strings.idleWarningMessage ||
"Your session will be terminated in"
} <strong id="attackbox-idle-countdown-time" class="attackbox-idle-countdown-time">--:--</strong>
</p>
</div>
<button id="attackbox-idle-close" class="attackbox-idle-close" type="button" aria-label="Close">
<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<line x1="18" y1="6" x2="6" y2="18"/>
<line x1="6" y1="6" x2="18" y2="18"/>
</svg>
</button>
</div>
<div class="attackbox-idle-warning-actions">
<button id="attackbox-idle-keep-active" class="attackbox-btn-keep-active" type="button">
<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<polyline points="20 6 9 17 4 12"/>
</svg>
${this.strings.idleKeepActive || "I'm Active"}
</button>
<button id="attackbox-idle-focus-mode" class="attackbox-btn-focus-mode" type="button">
<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="12" cy="12" r="3"/>
<path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"/>
</svg>
${this.strings.idleFocusMode || "Focus Mode"}
</button>
</div>
</div>
</div>
`;
$("body").append(html);
this.$idleWarning = $("#attackbox-idle-warning");
this.$idleCountdown = $("#attackbox-idle-countdown-time");
this.$idleMessage = $("#attackbox-idle-warning-message");
$("#attackbox-idle-close").on("click", () => this.hideIdleWarning());
}
bindIdleDetectionEvents() {
const self = this;
document.addEventListener("visibilitychange", function () {
self.isTabVisible = !document.hidden;
if (self.isTabVisible) {
self.recordUserActivity();
}
});
const activityEvents = ["mousedown", "keydown", "scroll", "touchstart"];
activityEvents.forEach((eventType) => {
document.addEventListener(
eventType,
function () {
self.recordUserActivity();
},
{ passive: true }
);
});
$("#attackbox-idle-keep-active").on("click", function (e) {
e.preventDefault();
self.keepSessionActive();
});
$("#attackbox-idle-focus-mode").on("click", function (e) {
e.preventDefault();
self.enableFocusMode();
});
}
recordUserActivity() {
this.lastUserActivity = Date.now();
if (this.idleWarningShown && this.$idleWarning.is(":visible")) {
this.hideIdleWarning();
}
}
startHeartbeat() {
if (this.heartbeatInterval) {
return; 
}
console.log("Starting session heartbeat");
this.sendHeartbeat();
this.heartbeatInterval = setInterval(() => {
this.sendHeartbeat();
}, HEARTBEAT_INTERVAL);
this.idleCheckInterval = setInterval(() => {
this.checkLocalIdleState();
}, IDLE_CHECK_INTERVAL);
}
stopHeartbeat() {
if (this.heartbeatInterval) {
clearInterval(this.heartbeatInterval);
this.heartbeatInterval = null;
}
if (this.idleCheckInterval) {
clearInterval(this.idleCheckInterval);
this.idleCheckInterval = null;
}
this.hideIdleWarning();
}
async sendHeartbeat() {
if (!this.sessionId || !this.hasActiveSession) {
return;
}
try {
const tokenData = await this.getToken();
const response = await fetch(
tokenData.api_url + "/sessions/" + this.sessionId + "/heartbeat",
{
method: "POST",
headers: {
"Content-Type": "application/json",
"X-Moodle-Token": tokenData.token,
Accept: "application/json",
},
body: JSON.stringify({
activity_type: "browser",
tab_visible: this.isTabVisible,
focus_mode: this.focusMode,
}),
}
);
if (!response.ok) {
console.warn("Heartbeat failed:", response.status);
return;
}
const data = await response.json();
if (data.success && data.data) {
this.handleHeartbeatResponse(data.data);
}
} catch (error) {
console.warn("Error sending heartbeat:", error);
}
}
handleHeartbeatResponse(data) {
this.idleThresholds = {
warning: data.idle_warning_threshold,
termination: data.idle_termination_threshold,
};
if (data.status === "terminated") {
this.handleSessionTerminated("idle_timeout");
return;
}
if (data.idle_critical) {
this.showIdleWarning(data, "critical");
} else if (data.idle_warning) {
this.showIdleWarning(data, "warning");
} else {
this.hideIdleWarning();
}
if (data.focus_mode !== this.focusMode) {
this.focusMode = data.focus_mode;
}
}
checkLocalIdleState() {
if (!this.hasActiveSession || this.focusMode) {
return;
}
const idleSeconds = (Date.now() - this.lastUserActivity) / 1000;
const warningThreshold = this.idleThresholds?.warning || 900;
if (idleSeconds >= warningThreshold && !this.idleWarningShown) {
this.showIdleWarning(
{
idle_seconds: idleSeconds,
time_until_termination:
(this.idleThresholds?.termination || 1800) - idleSeconds,
},
"warning"
);
}
}
showIdleWarning(data, level) {
if (this.focusMode) {
return; 
}
const timeUntilTermination = Math.max(
0,
data.time_until_termination || 0
);
const minutes = Math.floor(timeUntilTermination / 60);
const seconds = Math.floor(timeUntilTermination % 60);
this.$idleCountdown.text(
`${minutes}:${seconds.toString().padStart(2, "0")}`
);
if (level === "critical") {
this.$idleWarning.addClass("idle-critical").removeClass("idle-warning");
this.$idleMessage.html(
this.strings.idleCriticalMessage ||
"<strong>Critical:</strong> Your session will be terminated very soon due to inactivity!"
);
} else {
this.$idleWarning.addClass("idle-warning").removeClass("idle-critical");
this.$idleMessage.html(
this.strings.idleWarningMessage ||
"Your session has been idle. It will be automatically terminated to save resources."
);
}
if (!this.idleWarningShown) {
this.$idleWarning.fadeIn(300);
this.idleWarningShown = true;
this.playIdleAlertSound();
}
}
hideIdleWarning() {
if (this.idleWarningShown) {
this.$idleWarning.fadeOut(300);
this.idleWarningShown = false;
}
}
async keepSessionActive() {
this.recordUserActivity();
this.hideIdleWarning();
await this.sendHeartbeat();
}
async enableFocusMode() {
this.focusMode = true;
this.hideIdleWarning();
await this.sendHeartbeat();
alert(
"Focus mode enabled. Idle termination is now disabled for this session."
);
}
handleSessionTerminated(reason) {
this.stopHeartbeat();
this.stopSessionTimer();
this.sessionId = null;
this.hasActiveSession = false;
this.activeSessionUrl = null;
this.$button.removeClass("attackbox-btn-active");
this.$button.find(".attackbox-btn-text").text(this.strings.buttonText);
this.$button.attr("title", this.strings.buttonTooltip);
this.$terminateButton.hide();
if (reason === "idle_timeout") {
alert(
"Your session was terminated due to inactivity. You can launch a new session when needed."
);
}
}
playIdleAlertSound() {
try {
const audioContext = new (window.AudioContext ||
window.webkitAudioContext)();
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();
oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);
oscillator.frequency.value = 800;
oscillator.type = "sine";
gainNode.gain.value = 0.1;
oscillator.start();
setTimeout(() => {
oscillator.stop();
audioContext.close();
}, 200);
} catch (e) {
}
}
async checkExistingSession() {
try {
const tokenData = await this.getToken();
const response = await fetch(
tokenData.api_url + "/students/" + this.config.userId + "/sessions",
{
method: "GET",
headers: {
"X-Moodle-Token": tokenData.token,
Accept: "application/json",
},
}
);
if (!response.ok) {
return;
}
const data = await response.json();
if (
data.data &&
data.data.active_sessions &&
data.data.active_sessions.length > 0
) {
const session = data.data.active_sessions[0];
this.sessionId = session.session_id;
this.hasActiveSession = true;
this.activeSessionUrl =
session?.connection_info?.direct_url ||
session?.connection_info?.guacamole_connection_url ||
session?.connection_info?.guacamole_url ||
session?.direct_url ||
session?.guacamole_url ||
session?.url ||
session?.connection_url ||
null;
console.log("Session found on page load:", {
sessionId: this.sessionId,
status: session.status,
hasUrl: !!this.activeSessionUrl,
session: session,
});
if (this.activeSessionUrl) {
this.$button.addClass("attackbox-btn-active");
this.$button
.find(".attackbox-btn-text")
.text(this.strings.buttonTextActive);
this.$button.attr("title", this.strings.buttonTooltipActive);
this.$terminateButton.show();
console.log("Terminate button shown");
if (session.expires_at) {
this.startSessionTimer(session.expires_at);
}
this.startHeartbeat();
console.log("Existing session restored:", this.sessionId);
} else if (
session.status === "provisioning" ||
session.status === "pending"
) {
console.log(
"Session found but still provisioning, resuming polling..."
);
this.isLaunching = true;
this.showOverlay();
this.startPolling(tokenData.api_url);
} else {
console.warn(
"Session found in unexpected state:",
session.status,
session
);
}
}
} catch (error) {
console.log("No existing session found or error checking:", error);
}
}
createButton() {
const position = this.config.buttonPosition || "bottom-right";
const positionClasses = {
"bottom-right": "attackbox-btn-bottom-right",
"bottom-left": "attackbox-btn-bottom-left",
"top-right": "attackbox-btn-top-right",
"top-left": "attackbox-btn-top-left",
};
const html = `
<div id="attackbox-launcher" class="attackbox-launcher ${positionClasses[position]}">
<div id="attackbox-usage-badge" class="attackbox-usage-badge" style="display: none;">
<span class="attackbox-usage-text"></span>
</div>
<button id="attackbox-btn" class="attackbox-btn" type="button" title="${this.strings.buttonTooltip}">
<span class="attackbox-btn-icon">
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
<line x1="8" y1="21" x2="16" y2="21"></line>
<line x1="12" y1="17" x2="12" y2="21"></line>
<path d="M7 8l3 3-3 3M12 14h4"></path>
</svg>
</span>
<span class="attackbox-btn-text">${this.strings.buttonText}</span>
<span class="attackbox-btn-pulse"></span>
</button>
<button id="attackbox-terminate-btn" class="attackbox-btn-terminate" type="button" title="${this.strings.buttonTerminate}" style="display: none;">
<span class="attackbox-btn-icon">
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="12" cy="12" r="10"/>
<line x1="15" y1="9" x2="9" y2="15"/>
<line x1="9" y1="9" x2="15" y2="15"/>
</svg>
</span>
<span class="attackbox-btn-text">${this.strings.buttonTerminate}</span>
</button>
</div>
`;
$("body").append(html);
this.$button = $("#attackbox-btn");
this.$terminateButton = $("#attackbox-terminate-btn");
this.$launcher = $("#attackbox-launcher");
this.$timerBadge = $("#attackbox-timer-badge");
this.$timerText = $("#attackbox-timer-text");
}
createNotificationBanner() {
const html = `
<div id="attackbox-quota-notification" class="attackbox-quota-notification" style="display: none;">
<div class="attackbox-notification-content">
<span class="attackbox-notification-icon">&#9888;&#65039;</span>
<span id="attackbox-notification-message" class="attackbox-notification-message"></span>
<button id="attackbox-notification-close" class="attackbox-notification-close" type="button">×</button>
</div>
</div>
`;
$("body").append(html);
this.$notification = $("#attackbox-quota-notification");
this.$notificationMessage = $("#attackbox-notification-message");
$("#attackbox-notification-close").on("click", () => {
this.$notification.fadeOut(300);
});
}
createUsageDashboardLink() {
const html = `
<a href="${M.cfg.wwwroot}/local/attackbox/usage.php" 
id="attackbox-usage-link" 
class="attackbox-usage-link" 
title="${this.strings.buttonUsageDashboard}"
target="_blank">
<span class="attackbox-usage-link-icon">&#128202;</span>
<span class="attackbox-usage-link-text">Usage</span>
</a>
`;
this.$launcher.append(html);
}
createOverlay() {
const html = `
<div id="attackbox-overlay" class="attackbox-overlay" style="display: none;">
<div class="attackbox-overlay-scanlines"></div>
<div class="attackbox-overlay-content">
<div class="attackbox-overlay-header">
<div class="attackbox-overlay-logo">
<svg viewBox="0 0 100 100" class="attackbox-logo-svg">
<circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" stroke-width="2" opacity="0.3"/>
<circle cx="50" cy="50" r="35" fill="none" stroke="currentColor" stroke-width="1" opacity="0.5"/>
<path d="M50 20 L50 80 M20 50 L80 50" stroke="currentColor" stroke-width="1" opacity="0.3"/>
<circle cx="50" cy="50" r="8" fill="currentColor" class="attackbox-logo-core"/>
<path d="M30 30 L50 50 L70 30" fill="none" stroke="currentColor" stroke-width="2" class="attackbox-logo-arrow"/>
</svg>
</div>
<h1 class="attackbox-overlay-title">${this.strings.overlayTitle}</h1>
<p class="attackbox-overlay-subtitle">${this.strings.overlaySubtitle}</p>
</div>
<div class="attackbox-progress-container">
<div class="attackbox-progress-bar">
<div class="attackbox-progress-fill" id="attackbox-progress-fill"></div>
<div class="attackbox-progress-glow"></div>
</div>
<div class="attackbox-progress-text">
<span id="attackbox-progress-percent">0%</span>
<span id="attackbox-time-estimate" class="attackbox-time-estimate"></span>
</div>
</div>
<div class="attackbox-status-container">
<div class="attackbox-terminal">
<div class="attackbox-terminal-header">
<span class="attackbox-terminal-dot red"></span>
<span class="attackbox-terminal-dot yellow"></span>
<span class="attackbox-terminal-dot green"></span>
<span class="attackbox-terminal-title">cyberlynk@lynkbox:~$</span>
</div>
<div class="attackbox-terminal-body">
<div id="attackbox-status-message" class="attackbox-status-message">
<span class="attackbox-cursor">▋</span>
</div>
</div>
</div>
</div>
<!-- Educational Content -->
<div class="attackbox-edu-container">
<div class="attackbox-edu-header">
<svg class="attackbox-edu-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="12" cy="12" r="10"/>
<path d="M12 16v-4M12 8h.01"/>
</svg>
<span class="attackbox-edu-title">Did you know?</span>
</div>
<div class="attackbox-edu-content">
<div id="attackbox-edu-text" class="attackbox-edu-text"></div>
</div>
<div class="attackbox-edu-visual">
<div id="attackbox-attack-viz" class="attackbox-attack-viz">
<div class="attackbox-attack-node attackbox-attacker">
<span class="attackbox-node-icon">&#128100;</span>
<span class="attackbox-node-label">Attacker</span>
</div>
<div class="attackbox-attack-path" id="attackbox-attack-path"></div>
<div class="attackbox-attack-node attackbox-target">
<span class="attackbox-node-icon">&#127919;</span>
<span class="attackbox-node-label">Target</span>
</div>
</div>
<div id="attackbox-attack-label" class="attackbox-attack-label"></div>
</div>
</div>
<div class="attackbox-actions">
<button id="attackbox-cancel" class="attackbox-btn-cancel" type="button">
${this.strings.cancelButton}
</button>
</div>
</div>
<!-- Success state -->
<div id="attackbox-success" class="attackbox-success-container" style="display: none;">
<div class="attackbox-success-icon">
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="12" cy="12" r="10"/>
<path d="M8 12l2 2 4-4"/>
</svg>
</div>
<h2 class="attackbox-success-title">${this.strings.successTitle}</h2>
<p class="attackbox-success-message">${this.strings.successMessage}</p>
<button id="attackbox-open" class="attackbox-btn-success" type="button">
${this.strings.successOpen}
</button>
</div>
<!-- Error state -->
<div id="attackbox-error" class="attackbox-error-container" style="display: none;">
<div class="attackbox-error-icon">
<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
<circle cx="12" cy="12" r="10"/>
<line x1="15" y1="9" x2="9" y2="15"/>
<line x1="9" y1="9" x2="15" y2="15"/>
</svg>
</div>
<h2 class="attackbox-error-title">${this.strings.errorTitle}</h2>
<p id="attackbox-error-message" class="attackbox-error-message"></p>
<div class="attackbox-error-actions">
<button id="attackbox-retry" class="attackbox-btn-retry" type="button">
${this.strings.errorRetry}
</button>
<button id="attackbox-close-error" class="attackbox-btn-close" type="button">
${this.strings.errorClose}
</button>
</div>
</div>
</div>
`;
$("body").append(html);
this.$overlay = $("#attackbox-overlay");
this.$progressFill = $("#attackbox-progress-fill");
this.$progressPercent = $("#attackbox-progress-percent");
this.$timeEstimate = $("#attackbox-time-estimate");
this.$statusMessage = $("#attackbox-status-message");
this.$successContainer = $("#attackbox-success");
this.$errorContainer = $("#attackbox-error");
this.$overlayContent = this.$overlay.find(".attackbox-overlay-content");
}
bindEvents() {
const self = this;
this.$button.on("click", function (e) {
e.preventDefault();
self.launch();
});
this.$terminateButton.on("click", function (e) {
e.preventDefault();
self.terminateSession();
});
$("#attackbox-cancel").on("click", function (e) {
e.preventDefault();
self.cancel();
});
$("#attackbox-retry").on("click", function (e) {
e.preventDefault();
self.hideError();
self.launch();
});
$("#attackbox-close-error").on("click", function (e) {
e.preventDefault();
self.hideOverlay();
});
$("#attackbox-open").on("click", function (e) {
e.preventDefault();
if (self.activeSessionUrl) {
window.open(self.activeSessionUrl, "_blank", "noopener");
}
self.hideOverlay();
});
$(document).on("keydown.attackbox", function (e) {
if (e.key === "Escape" && self.$overlay.is(":visible")) {
self.cancel();
}
});
}
async launch() {
if (this.isLaunching) {
return;
}
if (!this.checkQuotaBeforeLaunch()) {
return;
}
this.isLaunching = true;
const $progressFill = $("#attackbox-progress-fill");
const $progressPercent = $("#attackbox-progress-percent");
const $timeEstimate = $("#attackbox-time-estimate");
const $statusMessage = $("#attackbox-status-message");
if ($progressFill.length) {
$progressFill.css("width", "0%");
}
if ($progressPercent.length) {
$progressPercent.text("0%");
}
if ($timeEstimate.length) {
$timeEstimate.hide().text("");
}
if ($statusMessage.length) {
$statusMessage.html('<span class="attackbox-cursor">▋</span>');
}
this.showOverlay();
await new Promise((resolve) => setTimeout(resolve, 50));
this.updateProgress(0, this.strings.progress5);
try {
this.updateProgress(5, this.strings.progress5);
const tokenData = await this.getToken();
this.updateProgress(10, this.strings.progress10);
const sessionData = await this.createSession(
tokenData.token,
tokenData.api_url
);
const session = sessionData.data || sessionData.body || sessionData;
if (!session || !session.session_id) {
throw new Error(sessionData.message || "Invalid response from API");
}
this.sessionId = session.session_id;
if (session.status === "ready" || session.status === "active") {
if (session.reused) {
this.handleExistingSession(session);
} else {
this.handleReady(session);
}
} else {
if (session.reused) {
this.updateProgress(
25,
"Waiting for existing session to be ready..."
);
}
this.startPolling(tokenData.api_url);
}
} catch (error) {
console.error("LynkBox launch error:", error);
this.showError(error.message || "Failed to launch LynkBox");
}
}
async getToken() {
const response = await fetch(
this.config.tokenEndpoint + "?sesskey=" + this.config.sesskey,
{
method: "GET",
credentials: "same-origin",
headers: {
Accept: "application/json",
},
}
);
if (!response.ok) {
throw new Error("Failed to get authentication token");
}
const data = await response.json();
if (!data.success) {
throw new Error(data.error || "Token generation failed");
}
return data;
}
async createSession(token, apiUrl) {
const response = await fetch(apiUrl + "/sessions", {
method: "POST",
headers: {
"Content-Type": "application/json",
"X-Moodle-Token": token,
},
body: JSON.stringify({
student_id: String(this.config.userId),
student_name: this.config.userFullname,
metadata: {
source: "moodle_attackbox_plugin",
page_url: window.location.href,
},
}),
});
if (!response.ok) {
const errorData = await response.json().catch(() => ({}));
console.log("API error response:", errorData);
const quotaData = errorData.details || errorData.data || errorData;
if (response.status === 403 && quotaData.error === "quota_exceeded") {
const hoursUsed =
Math.round((quotaData.consumed_minutes / 60) * 10) / 10;
const hoursLimit =
Math.round((quotaData.quota_minutes / 60) * 10) / 10;
const resetDate = new Date(quotaData.resets_at).toLocaleDateString();
throw new Error(
`Monthly usage limit reached!<br><br>` +
`<strong>Plan:</strong> ${quotaData.plan || "Freemium"}<br>` +
`<strong>Used:</strong> ${hoursUsed}h / ${hoursLimit}h<br><br>` +
`Your quota resets on <strong>${resetDate}</strong>.<br><br>` +
`<a href="/local/attackbox/upgrade.php" style="color: #00ff88; text-decoration: underline;">Upgrade your plan</a> for more hours.`
);
}
throw new Error(
errorData.error ||
errorData.message ||
`API error: ${response.status}`
);
}
return await response.json();
}
startPolling(apiUrl) {
const self = this;
const pollInterval = this.config.pollInterval || 3000;
let attempts = 0;
const maxAttempts = 200; 
console.log("Starting polling for session status");
this.pollTimer = setInterval(async function () {
attempts++;
if (attempts > maxAttempts) {
self.stopPolling();
self.showError("Session creation timed out. Please try again.");
return;
}
try {
const response = await fetch(apiUrl + "/sessions/" + self.sessionId, {
method: "GET",
headers: {
Accept: "application/json",
},
});
if (!response.ok) {
throw new Error("Failed to get session status");
}
const data = await response.json();
const session = data.data || data.body || data;
if (!session || !session.session_id) {
return;
}
let progress;
let message;
let timeEstimate;
if (session.stage_message && session.progress) {
progress = session.progress;
message = session.stage_message;
timeEstimate = self.getTimeEstimate(session, progress);
if (session.stage === "waiting_health") {
console.log("Health check progress:", {
progress: progress,
message: message,
health_checks: session.health_checks,
timeEstimate: timeEstimate,
});
}
} else if (session.provisioning_stage === "waiting_health_checks") {
const healthInfo = session.health_checks || {};
const systemStatus = healthInfo.system_status || "unknown";
const instanceStatus = healthInfo.instance_status || "unknown";
progress = 85;
message = `Instance running, verifying readiness... (System: ${systemStatus}, Instance: ${instanceStatus})`;
timeEstimate = self.getTimeEstimate(session, progress);
console.log("Waiting for health checks:", healthInfo);
} else {
progress =
session.progress ||
self.estimateProgress(session.status, attempts);
message = self.getProgressMessage(progress);
timeEstimate = self.getTimeEstimate(session, progress);
if (session.instance_state) {
if (session.instance_state === "pending") {
message = "Starting instance from warm pool...";
progress = Math.min(progress, 60);
timeEstimate = self.getTimeEstimate(session, progress);
} else if (
session.instance_state === "running" &&
session.status === "provisioning"
) {
message = "Instance running, initializing services...";
progress = Math.max(progress, 75);
timeEstimate = self.getTimeEstimate(session, progress);
}
}
}
self.updateProgress(progress, message, timeEstimate);
if (session.status === "ready" || session.status === "active") {
self.stopPolling();
self.handleReady(session);
} else if (
session.status === "error" ||
session.status === "terminated"
) {
self.stopPolling();
self.showError(session.error || "Session failed to start");
}
} catch (error) {
console.error("Polling error:", error);
}
}, pollInterval);
}
stopPolling() {
if (this.pollTimer) {
clearInterval(this.pollTimer);
this.pollTimer = null;
}
}
estimateProgress(status, attempts) {
const baseProgress = {
pending: 10,
provisioning: 25,
ready: 100,
active: 100,
};
let progress = baseProgress[status] || 10;
if (status === "provisioning") {
progress = Math.min(94, 25 + attempts * 2);
}
return progress;
}
getProgressMessage(progress) {
const thresholds = PROGRESS_THRESHOLDS.slice().sort((a, b) => b - a);
for (const threshold of thresholds) {
if (progress >= threshold) {
const key = "progress" + threshold;
return this.strings[key] || "Processing...";
}
}
return this.strings.progress5 || "Initializing...";
}
handleExistingSession(session) {
this.isLaunching = false;
this.hasActiveSession = true;
console.log("Full session object:", session);
if (session.status !== "ready" && session.status !== "active") {
console.warn("Session not ready yet, status:", session.status);
this.showError(
`Session is ${session.status}. Please wait a moment and try again.`
);
return;
}
this.activeSessionUrl =
session?.connection_info?.direct_url ||
session?.connection_info?.guacamole_connection_url ||
session?.direct_url ||
session?.guacamole_url ||
session?.url ||
session?.connection_url ||
null;
console.log("Existing session found, URL:", this.activeSessionUrl);
if (this.activeSessionUrl) {
this.updateProgress(100, this.strings.progress100);
this.$button.addClass("attackbox-btn-active");
this.$button
.find(".attackbox-btn-text")
.text(this.strings.buttonTextActive);
this.$button.attr("title", this.strings.buttonTooltipActive);
this.$terminateButton.show();
if (session.expires_at) {
this.startSessionTimer(session.expires_at);
}
this.startHeartbeat();
setTimeout(() => {
this.showSuccess();
}, 500);
} else {
console.error("No connection URL in session:", session);
console.error("Available keys:", Object.keys(session));
this.showError(
"Session found but no connection URL available. Please check CloudWatch logs or try terminating and creating a new session."
);
}
}
handleReady(session) {
this.isLaunching = false;
this.hasActiveSession = true;
console.log("Full session object (ready):", session);
this.activeSessionUrl =
session?.connection_info?.direct_url ||
session?.connection_info?.guacamole_connection_url ||
session?.direct_url ||
session?.guacamole_url ||
session?.url ||
session?.connection_url ||
null;
console.log("LynkBox ready, URL:", this.activeSessionUrl);
if (this.activeSessionUrl) {
this.updateProgress(100, this.strings.progress100);
this.$button.addClass("attackbox-btn-active");
this.$button
.find(".attackbox-btn-text")
.text(this.strings.buttonTextActive);
this.$button.attr("title", this.strings.buttonTooltipActive);
this.$terminateButton.show();
if (session.expires_at) {
this.startSessionTimer(session.expires_at);
}
this.startHeartbeat();
setTimeout(() => {
this.showSuccess();
}, 500);
} else {
console.error("No connection URL in session:", session);
console.error("Available keys:", Object.keys(session));
this.showError(
"LynkBox is ready but no connection URL available. Please check CloudWatch logs or contact support."
);
}
}
updateProgress(percent, message, timeEstimate) {
this.$progressFill.css("width", percent + "%");
this.$progressPercent.text(percent + "%");
if (message) {
this.typeMessage(message);
}
if (timeEstimate) {
this.updateTimeEstimate(timeEstimate);
}
}
updateTimeEstimate(estimate) {
const $timeEstimate = $("#attackbox-time-estimate");
if (estimate) {
$timeEstimate.text(estimate).fadeIn(200);
} else {
$timeEstimate.fadeOut(200);
}
}
getTimeEstimate(session, progress) {
if (!session) return null;
const status = session.status;
const stage = session.stage || session.provisioning_stage;
if (status === "ready" || status === "active") {
return null;
}
if (status === "pending") {
return "⏱ ~5-15 seconds";
}
if (status === "provisioning") {
if (
stage === "instance_starting" ||
session.stage_message?.includes("Starting")
) {
if (progress < 40) {
return "⏱ ~30-60 seconds";
} else {
return "⏱ ~20-40 seconds";
}
} else if (
stage === "waiting_health" ||
stage === "waiting_health_checks"
) {
const healthChecks = session.health_checks || {};
const systemStatus = healthChecks.system_status;
const instanceStatus = healthChecks.instance_status;
if (systemStatus === "passed" && instanceStatus === "passed") {
return "⏱ ~5-10 seconds";
} else if (
systemStatus === "initializing" ||
instanceStatus === "initializing"
) {
return "⏱ ~60-120 seconds";
} else {
return "⏱ ~30-90 seconds";
}
} else if (stage === "allocating" || progress < 15) {
return "⏱ ~1-3 minutes";
} else if (progress >= 85) {
return "⏱ ~10-20 seconds";
} else {
return "⏱ ~1-2 minutes";
}
}
return "⏱ ~1-2 minutes";
}
typeMessage(message) {
const $container = this.$statusMessage;
$container.html(
'<span class="attackbox-typed"></span><span class="attackbox-cursor">▋</span>'
);
const $typed = $container.find(".attackbox-typed");
let index = 0;
const type = () => {
if (index < message.length) {
$typed.text($typed.text() + message[index]);
index++;
setTimeout(type, 20);
}
};
type();
}
showOverlay() {
this.$overlay.fadeIn(300);
this.$overlayContent.show();
this.$successContainer.hide();
this.$errorContainer.hide();
$("body").addClass("attackbox-overlay-open");
this.startEducationalContent();
}
hideOverlay() {
this.$overlay.fadeOut(300);
$("body").removeClass("attackbox-overlay-open");
this.isLaunching = false;
this.stopEducationalContent();
}
showSuccess() {
this.$overlayContent.fadeOut(200, () => {
this.$successContainer.fadeIn(200);
});
}
async updateUsageDisplay() {
try {
const response = await fetch(
M.cfg.wwwroot +
"/local/attackbox/ajax/get_usage.php?sesskey=" +
this.config.sesskey,
{
method: "GET",
credentials: "same-origin",
headers: {
Accept: "application/json",
},
}
);
if (!response.ok) {
console.warn("Failed to fetch usage data");
return;
}
const data = await response.json();
if (!data.success) {
console.warn("Usage data error:", data.message);
return;
}
this.currentUsageData = data;
this.checkQuotaWarnings(data);
const $badge = $("#attackbox-usage-badge");
const $badgeText = $badge.find(".attackbox-usage-text");
if (data.hours_limit === "Unlimited") {
$badgeText.html(`<strong>${data.plan}:</strong> Unlimited`);
$badge
.removeClass("usage-low usage-medium usage-high")
.addClass("usage-unlimited");
} else {
$badgeText.html(
`<strong>${data.plan}:</strong> ${data.hours_used}h / ${data.hours_limit}h ` +
`<span class="usage-remaining">(${data.hours_remaining}h left)</span>`
);
$badge.removeClass(
"usage-low usage-medium usage-high usage-unlimited"
);
if (data.percentage >= 90) {
$badge.addClass("usage-high");
} else if (data.percentage >= 70) {
$badge.addClass("usage-medium");
} else {
$badge.addClass("usage-low");
}
}
$badge.fadeIn(300);
} catch (error) {
console.error("Error updating usage display:", error);
}
}
checkQuotaWarnings(data) {
if (data.hours_limit === "Unlimited" || data.percentage === undefined) {
return;
}
const percentage = data.percentage;
let warningLevel = null;
let message = "";
if (percentage >= 100) {
warningLevel = "critical";
message = `<strong>Quota Exhausted!</strong> You've used all ${data.hours_limit}h of your ${data.plan} plan. Quota resets ${data.reset_date}.`;
} else if (percentage >= 90) {
warningLevel = "high";
message = `<strong>Low on Time!</strong> Only ${data.hours_remaining}h remaining of your ${data.hours_limit}h ${data.plan} quota.`;
} else if (percentage >= 80) {
warningLevel = "medium";
message = `<strong>Heads up!</strong> You've used ${data.hours_used}h of ${data.hours_limit}h. ${data.hours_remaining}h remaining.`;
}
if (warningLevel && warningLevel !== this.lastQuotaWarning) {
this.showQuotaWarning(message, warningLevel);
this.lastQuotaWarning = warningLevel;
}
}
showQuotaWarning(message, level) {
this.$notificationMessage.html(message);
this.$notification
.removeClass("warning-medium warning-high warning-critical")
.addClass(`warning-${level}`);
this.$notification.fadeIn(300);
if (level === "medium") {
setTimeout(() => {
this.$notification.fadeOut(300);
}, 10000);
}
}
checkQuotaBeforeLaunch() {
if (!this.currentUsageData) {
return true; 
}
const data = this.currentUsageData;
if (data.hours_limit !== "Unlimited" && data.percentage >= 100) {
this.showError(
`Monthly usage limit reached!<br><br>` +
`<strong>Plan:</strong> ${data.plan}<br>` +
`<strong>Used:</strong> ${data.hours_used}h / ${data.hours_limit}h<br><br>` +
`Your quota resets on <strong>${data.reset_date}</strong>.<br><br>` +
`<a href="/local/attackbox/upgrade.php" style="color: #00ff88; text-decoration: underline;">Upgrade your plan</a> for more hours.`
);
return false;
}
if (data.hours_limit !== "Unlimited" && data.minutes_remaining < 10) {
const confirmMsg = `You only have ${data.minutes_remaining} minutes remaining in your quota. Continue?`;
return confirm(confirmMsg);
}
return true;
}
showError(message) {
this.isLaunching = false;
$("#attackbox-error-message").html(message); 
this.$overlayContent.fadeOut(200, () => {
this.$errorContainer.fadeIn(200);
});
}
hideError() {
this.$errorContainer.hide();
this.$overlayContent.show();
this.updateProgress(0, "");
}
cancel() {
this.stopPolling();
this.isLaunching = false;
this.hideOverlay();
}
startSessionTimer(expiresAt) {
this.sessionExpiresAt = new Date(expiresAt);
this.stopSessionTimer(); 
this.updateTimerDisplay();
this.timerInterval = setInterval(() => {
this.updateTimerDisplay();
}, 1000);
this.$timerBadge.fadeIn(300);
}
stopSessionTimer() {
if (this.timerInterval) {
clearInterval(this.timerInterval);
this.timerInterval = null;
}
this.sessionExpiresAt = null;
this.$timerBadge.fadeOut(300);
}
startEducationalContent() {
this.rotateEducationalContent();
this.eduInterval = setInterval(() => {
this.rotateEducationalContent();
}, 5000);
}
stopEducationalContent() {
if (this.eduInterval) {
clearInterval(this.eduInterval);
this.eduInterval = null;
}
}
rotateEducationalContent() {
const $eduText = $("#attackbox-edu-text");
const $attackLabel = $("#attackbox-attack-label");
const $attackPath = $("#attackbox-attack-path");
if (!$eduText.length) return;
$eduText.css("opacity", "0");
$attackLabel.css("opacity", "0");
setTimeout(() => {
const tip = this.eduContent[this.currentEduIndex];
$eduText.text(tip);
const attack = this.attackTypes[this.currentAttackIndex];
$attackLabel.html(`<strong>${attack.icon} ${attack.name}</strong>`);
$attackPath.css(
"background",
`linear-gradient(90deg, ${attack.color}, transparent)`
);
$attackPath.attr(
"data-attack",
attack.name.toLowerCase().replace(/\\s+/g, "-")
);
$eduText.css("opacity", "1");
$attackLabel.css("opacity", "1");
this.currentEduIndex =
(this.currentEduIndex + 1) % this.eduContent.length;
this.currentAttackIndex =
(this.currentAttackIndex + 1) % this.attackTypes.length;
}, 300);
}
updateTimerDisplay() {
if (!this.sessionExpiresAt) {
return;
}
const now = new Date();
const remaining = this.sessionExpiresAt - now;
if (remaining <= 0) {
this.$timerText.text("Expired");
this.$timerBadge.addClass("timer-expired");
this.stopSessionTimer();
setTimeout(() => {
this.sessionId = null;
this.hasActiveSession = false;
this.activeSessionUrl = null;
this.$button.removeClass("attackbox-btn-active");
this.$button
.find(".attackbox-btn-text")
.text(this.strings.buttonText);
this.$button.attr("title", this.strings.buttonTooltip);
this.$terminateButton.hide();
alert("Your session has expired. Please launch a new session.");
}, 2000);
return;
}
const totalMinutes = Math.floor(remaining / (1000 * 60));
const hours = Math.floor(totalMinutes / 60);
const minutes = totalMinutes % 60;
let timeText;
if (hours > 0) {
timeText = `${hours}h ${minutes}m`;
} else {
timeText = `${minutes}m`;
}
this.$timerText.text(timeText);
this.$timerBadge.removeClass(
"timer-low timer-medium timer-high timer-expired"
);
if (totalMinutes <= 5) {
this.$timerBadge.addClass("timer-low");
} else if (totalMinutes <= 15) {
this.$timerBadge.addClass("timer-medium");
} else {
this.$timerBadge.addClass("timer-high");
}
}
async terminateSession() {
if (!this.sessionId) {
console.warn("No session ID to terminate");
return;
}
if (!confirm(this.strings.terminateConfirm)) {
return;
}
try {
const $btnText = this.$terminateButton.find(".attackbox-btn-text");
const originalText = $btnText.text();
this.$terminateButton.prop("disabled", true);
this.$terminateButton.css("opacity", "0.6");
$btnText.html('<span class="spinner"></span> Ending...');
const tokenData = await this.getToken();
const response = await fetch(
tokenData.api_url + "/sessions/" + this.sessionId,
{
method: "DELETE",
headers: {
"X-Moodle-Token": tokenData.token,
"Content-Type": "application/json",
Accept: "application/json",
},
body: JSON.stringify({
reason: "user_requested",
stop_instance: false, 
}),
}
);
if (!response.ok) {
const errorData = await response.json().catch(() => ({}));
throw new Error(
errorData.message ||
`Failed to terminate session: ${response.status}`
);
}
this.sessionId = null;
this.hasActiveSession = false;
this.activeSessionUrl = null;
this.stopSessionTimer();
this.stopHeartbeat();
this.$button.removeClass("attackbox-btn-active");
this.$button.find(".attackbox-btn-text").text(this.strings.buttonText);
this.$button.attr("title", this.strings.buttonTooltip);
this.$terminateButton.hide();
this.$terminateButton.prop("disabled", false);
this.$terminateButton.css("opacity", "1");
alert(this.strings.terminateSuccess);
} catch (error) {
console.error("Terminate session error:", error);
this.$terminateButton.prop("disabled", false);
this.$terminateButton.css("opacity", "1");
this.$terminateButton
.find(".attackbox-btn-text")
.text(this.strings.buttonTerminate);
alert(this.strings.terminateError + ": " + error.message);
}
}
}
const loadStrings = function () {
return Str.get_strings(STRING_KEYS).then(function (results) {
const strings = {};
const keyNames = [
"buttonText",
"buttonTextActive",
"buttonTerminate",
"buttonTooltip",
"buttonTooltipActive",
"buttonUsageDashboard",
"timerTimeRemaining",
"overlayTitle",
"overlaySubtitle",
"cancelButton",
"errorTitle",
"errorRetry",
"errorClose",
"successTitle",
"successMessage",
"successOpen",
"terminateConfirm",
"terminateSuccess",
"terminateError",
"idleWarningTitle",
"idleWarningMessage",
"idleCriticalMessage",
"idleKeepActive",
"idleFocusMode",
"progress5",
"progress10",
"progress18",
"progress25",
"progress33",
"progress42",
"progress50",
"progress62",
"progress70",
"progress85",
"progress94",
"progress100",
];
keyNames.forEach(function (key, index) {
strings[key] = results[index];
});
return strings;
});
};
return {
init: function (config) {
$(document).ready(function () {
loadStrings()
.then(function (strings) {
new AttackBoxLauncher(config, strings);
})
.catch(function (error) {
console.error("Failed to load LynkBox strings:", error);
});
});
},
};
});
